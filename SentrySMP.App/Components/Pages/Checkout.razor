@page "/checkout"
@using SentrySMP.Shared.DTOs
@using Microsoft.AspNetCore.WebUtilities
@using SentrySMP.App.Components.State
@using System.Text.Json
@using System.Net.Http.Json
@inject SentrySMP.App.Components.State.CartState CartState
@inject Microsoft.Extensions.Configuration.IConfiguration Configuration
@inject Microsoft.AspNetCore.Hosting.IWebHostEnvironment Env
@inject NavigationManager NavigationManager
@inject Microsoft.JSInterop.IJSRuntime JS
@inject SentrySMP.Shared.Interfaces.ICheckoutApi CheckoutApi
@inject System.Net.Http.HttpClient Http
@inject SentrySMP.Shared.Interfaces.ITransactionsService TransactionsService
@inject SentrySMP.App.Authentication.UserService UserService
@inject SentrySMP.Shared.Interfaces.IRconService RconService
@inject SentrySMP.Shared.Interfaces.IServerService ServerService
@inject Microsoft.Extensions.Logging.ILoggerFactory LoggerFactory
@inject SentrySMP.App.Services.IBackgroundTaskQueue BackgroundQueue
@inject SentrySMP.Shared.Interfaces.ISentryApi SentryApi
@rendermode InteractiveServer
<PageTitle>Checkout - SentrySMP</PageTitle>

<div class="main-wrapper">
    <h1 class="main">Checkout</h1>
</div>
    @if (_paymentSucceeded)
    {
        <div style="font-size: 5rem; text-align:center; color:#44ae44;">
            <i class="bi bi-check-circle"></i> 
        </div>
        <div class="alert alert-success mt-4">

            <div class="info">
                @(_successMessage ?? "Payment successful.")
            </div>
            @if (_wasRedirectStatusSuccess && string.IsNullOrWhiteSpace(_rconStatusMessage) && string.IsNullOrWhiteSpace(_failureMessage))
            {
                <p><em>If the webpage keeps reloading, <u>it wants to send you your purchased items</u>.</em>If the problem persists, please contact us.</p>
            }
            <button @onclick="ContinueShopping">Continue shopping</button>
        </div>

        @if (_rconResult != null)
        {
                <h2>Status</h2>
                <div class="table-wrapper">
                    <table>
                        <thead>
                            <tr>
                                <th>Command</th>
                                <th class="text-center">Status</th>
                                <th>Response</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var cr in _rconResult.CommandResults)
                            {
                                <tr class="@(cr.Succeeded ? "table-success" : "table-danger")">
                                    <td style="min-width:240px;">@cr.CommandText</td>
                                    <td class="text-center" style="color: @(cr.Succeeded ? "#44ae44" : "#dc3545")">@(cr.Succeeded ? "OK" : "FAILED")</td>
                                    <td>
                                        @if (!string.IsNullOrEmpty(cr.Response))
                                        {
                                            <div>
                                                <span title="@CleanSingleLine(cr.Response)" style="display:inline-block; max-width:420px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">@TruncateCompact(cr.Response, 80)</span>
                                            </div>
                                        }
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
        }

        @if (_lastOrderItems != null && _lastOrderItems.Count > 0)
        {
            <div class="card mt-3">
                <div class="card-body">
                    <h2>Order details</h2>
                    <div class="table-wrapper">
                        <table class="table table-sm mt-2">
                            <thead>
                                <tr>
                                    <th>Item</th>
                                    <th>Server</th>
                                    <th class="text-center">Qty</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var it in _lastOrderItems)
                                {
                                    <tr>
                                        <td class="table-cell-wrap">@FormatPlayerToken(it.Key.Name)</td>
                                        <td class="table-cell-nowrap">@(it.Key.Server?.Name ?? "-")</td>
                                        <td class="text-center table-cell-nowrap">@it.Quantity</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        }
    }
    else if (CartState.CartItems.Count == 0)
    {
        <div class="alert alert-info mt-4">
            <i class="bi bi-info-circle"></i> Your cart is empty. <button @onclick="ContinueShopping">Continue shopping</button>
        </div>
    }
    else
    {
        <div class="cart-total">€@CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity).ToString("F2")</div>
        <div class="card mt-4">
            <div class="card-body">
                <h2 class="card-title">Order summary</h2>
                <div class="table-wrapper">
                    <table class="table table-sm mt-3">
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th class="text-center">Qty</th>
                                <th class="text-end">Unit</th>
                                <th class="text-end">Line</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var item in CartState.CartItems)
                            {
                                var p = item.Key;
                                var qty = item.Quantity;
                                double unitPrice = p.Sale > 0 ? Convert.ToDouble(p.Price) * (1 - p.Sale / 100.0) : Convert.ToDouble(p.Price);
                                <tr>
                                    <td class="table-cell-wrap">@FormatPlayerToken(p.Name) <small class="text-muted">@p.Server?.Name</small></td>
                                    <td class="text-center table-cell-nowrap">@qty</td>
                                    <td class="text-end table-cell-nowrap">€@unitPrice.ToString("F2")</td>
                                    <td class="text-end table-cell-nowrap">€@((unitPrice * qty).ToString("F2"))</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
                <h2 class="mt-3">Server status</h2>
                @if (_serverHealth.Count > 0)
                {
                    <ul class="list-unstyled mt-2" style="list-style-type: none;">
                        @foreach (var sh in _serverHealth.GroupBy(h => h.Server.Id).Select(g => g.First()))
                        {
                            <li class="d-flex align-items-center gap-2 py-1">
                                <i class="bi bi-circle-fill" style="color: #@(sh.Ok ? "44ae44" : "dc3545")"></i>
                                <span class="me-2">@sh.Server.Name</span>
                                @if (!sh.Ok && !string.IsNullOrWhiteSpace(sh.Error))
                                {
                                    <small style="margin-left: 5px;" class="text-muted">@TruncateCompact(sh.Error, 80)</small>
                                }
                                else {
                                    <small style="margin-left: 5px;" class="text-muted">Server is ready.</small>
                                }
                            </li>
                        }
                    </ul>
                }
                else
                {
                    <div class="small text-muted">No servers associated with items in your cart.</div>
                }
                <h2 class="mt-3">Choose payment method</h2>
                @if (_paymentsDisabled)
                {
                    <div class="alert alert-warning mt-3">
                        <i class="bi bi-exclamation-triangle-fill me-2"></i>
                        <strong>Payments are temporarily disabled</strong>
                        <div class="mt-2">All payment methods are currently unavailable. Please check back later.</div>
                    </div>
                }
                else
                {
                    <div class="mt-2">
                        <div class="payment-options d-flex flex-wrap gap-2">
                            @if (!_stripeDisabled)
                            {
                                <div class="payment-option @( _selectedPayment=="stripe" ? "selected" : "")" role="button" @onclick="SelectStripe">
                                    <div class="d-flex align-items-center gap-2">
                                        <i class="bi bi-bank fs-3"></i>
                                        <div>
                                            <strong>Stripe</strong>
                                            <div class="small text-muted">You will be redirected to the payment gateway. After successful payment, your items will be delivered to your account automatically. Available payment methods include <b>credit/debit card (Google Pay, Apple Pay, etc.), Bancontact, Multibanco, MobilePay, Klarna, Revolut Pay, and EPS</b>. Sorry, Apple Pay is not supported.</div>
                                        </div>
                                    </div>
                                </div>
                            }
                            @if (!_payPalDisabled)
                            {
                                <div class="payment-option @( _selectedPayment=="paypal" ? "selected" : "")" role="button" @onclick="SelectPaypal">
                                    <div class="d-flex align-items-center gap-2">
                                        <i class="bi bi-paypal fs-3"></i>
                                        <div>
                                            <strong>PayPal</strong>
                                            <div class="small text-muted">You will be redirected to the payment gateway. After successful payment, your items will be delivered to your account automatically. You can choose to pay either with your <b>PayPal account or with a debit card via PayPal</b>.</div>
                                        </div>
                                    </div>
                                </div>
                            }
                        </div>
                    </div>

                    @if (_stripeDisabled && _payPalDisabled)
                    {
                        <div class="alert alert-warning mt-3">
                            <i class="bi bi-exclamation-triangle-fill me-2"></i>
                            <strong>No payment methods available</strong>
                            <div class="mt-2">All payment methods are currently disabled. Please contact support.</div>
                        </div>
                    }
                }

                <div class="mt-4 d-flex gap-2">
                    <button class="btn btn-primary" @onclick="ProceedToPayment" disabled="@(!_canProceedToPayment || _paymentsDisabled || (_stripeDisabled && _payPalDisabled))">Proceed to payment</button>
                    <button class="secondary" @onclick="BackToCart">Back to cart</button>
                </div>

                @if (_hasUnavailableServers)
                {
                    <div class="alert alert-warning mt-2">
                        The server is unavailable, so you won't receive the items you purchased. Would you like to remove them from your cart?
                        <div class="mt-2">
                            <button class="danger" @onclick="RemoveUnavailableServerItems">Remove unavailable items</button>
                            <button class="secondary" @onclick="BackToCart">Back to cart</button>
                        </div>
                    </div>
                }

                @if (_showPaymentCard)
                {
                    @if (_selectedPayment == "paypal")
                    {
                        <div class="mt-3">
                            <div id="paypal-button-container"></div>
                            <div class="mt-2">
                                <button class="btn btn-outline-secondary" @onclick="CancelPayment">Cancel</button>
                            </div>
                        </div>
                        @if (!string.IsNullOrWhiteSpace(_payPalErrorMessage))
                        {
                            <div class="alert alert-danger mt-2">PayPal error: @_payPalErrorMessage</div>
                        }
                    }
                }

                @if (_paymentSucceeded)
                {
                    <div class="alert alert-success mt-3">
                        <div style="font-size: 5rem; text-align:center; color:#44ae44;">
                            <i class="bi bi-check-circle"></i> 
                        </div>
                        <div class="info">
                            <p><em>If the webpage keeps reloading, <u>it wants to send you your purchased items</u>.</em>If the problem persists, please contact us.</p>
                            @(_successMessage ?? "Payment successful.")
                        </div>
                        <button @onclick="ContinueShopping">Continue shopping</button>
                    </div>


                    @if (_rconResult != null)
                    {
                            <h2>Status</h2>
                            <div class="table-wrapper">
                                <table class="">
                                    <thead>
                                        <tr>
                                            <th>Command</th>
                                            <th class="text-center">Status</th>
                                            <th>Response</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @foreach (var cr in _rconResult.CommandResults)
                                        {
                                            <tr class="@(cr.Succeeded ? "table-success" : "table-danger")">
                                                <td style="min-width:240px;">@cr.CommandText</td>
                                                <td class="text-center" style="color: @(cr.Succeeded ? "#44ae44" : "#dc3545")">@(cr.Succeeded ? "OK" : "FAILED")</td>
                                                <td>
                                                    @if (!string.IsNullOrEmpty(cr.Response))
                                                    {
                                                        <div>
                                                            <span title="@CleanSingleLine(cr.Response)" style="display:inline-block; max-width:420px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis;">@TruncateCompact(cr.Response, 80)</span>
                                                        </div>
                                                    }
                                                </td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                                </div>
                    }

                    @if (_lastOrderItems != null && _lastOrderItems.Count > 0)
                    {
                        <div class="card mt-3">
                            <div class="card-body">
                                <h6>Order details</h6>
                                <div class="table-wrapper">
                                    <table class="table table-sm mt-2">
                                        <thead>
                                            <tr>
                                                <th>Item</th>
                                                <th>Server</th>
                                                <th class="text-center">Qty</th>
                                            </tr>
                                        </thead>
                                        <tbody>
                                            @foreach (var it in _lastOrderItems)
                                            {
                                                <tr>
                                                    <td class="table-cell-wrap">@FormatPlayerToken(it.Key.Name)</td>
                                                    <td class="table-cell-nowrap">@(it.Key.Server?.Name ?? "-")</td>
                                                    <td class="text-center table-cell-nowrap">@it.Quantity</td>
                                                </tr>
                                            }
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                    }
                }

                @if (!string.IsNullOrWhiteSpace(_failureMessage))
                {
                    <div class="alert alert-danger mt-3">
                        <i class="bi bi-x-circle"></i> @_failureMessage
                        <div class="mt-2">
                            @if (_failureMessage.Contains("cancelled"))
                            {
                                <button class="btn btn-sm btn-primary" @onclick="ProceedToPayment">Try payment again</button>
                            }
                            else
                            {
                                <button @onclick="ContinueShopping">Continue shopping</button>
                            }
                        </div>
                    </div>
                }

            </div>
        </div>


@code {
    private class ServerHealth
    {
        public SentrySMP.Shared.DTOs.ServerResponse Server { get; set; } = new();
        public bool Ok { get; set; }
        public string? Error { get; set; }
        public string? HostUsed { get; set; }
        public int PortUsed { get; set; }
    }

    private string _selectedPayment = "stripe";
    private bool _showPaymentCard = false;
    private bool _paymentSucceeded = false;
    private string _amount = ""; // default amount (start empty; cart total will prefill if available)
    private string? _successMessage;
    private string? _failureMessage;
    private readonly List<ServerHealth> _serverHealth = new();
    private bool _hasUnavailableServers = false;
    private bool _canProceedToPayment = false; // enabled only when all relevant servers are OK
    private PaymentSettingsResponse? _paymentSettings;
    private bool _paymentsDisabled = false;
    private bool _stripeDisabled = false;
    private bool _payPalDisabled = false;

    protected override async Task OnInitializedAsync()
    {
        CartState.OnChange += HandleCartChanged;
        
        // Load payment settings first
        try
        {
            _paymentSettings = await SentryApi.GetPaymentSettingsAsync();
            if (_paymentSettings != null)
            {
                _paymentsDisabled = !_paymentSettings.EnablePayments;
                _stripeDisabled = _paymentSettings.DisableStripe;
                _payPalDisabled = _paymentSettings.DisablePayPal;
                
                // Auto-select first available payment method
                if (!_paymentsDisabled)
                {
                    if (!_stripeDisabled)
                    {
                        _selectedPayment = "stripe";
                    }
                    else if (!_payPalDisabled)
                    {
                        _selectedPayment = "paypal";
                    }
                }
            }
        }
        catch (Exception ex)
        {
            _logger?.LogWarning(ex, "Failed to load payment settings");
        }
        
        // Load cart from browser storage (important when arriving via redirect)
        try
        {
            await CartState.LoadFromStorageAsync(JS);
        }
        catch { }
        // Initial server availability check
        try { await CheckServersAsync(); } catch { }

        // Prefill amount from cart total if we have items
        var total = CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
        if (total > 0)
        {
            _amount = total.ToString("F2");
        }

        // Load username for UI token replacement
        try
        {
            var u = await UserService.GetUsernameAsync();
            _username = (u ?? string.Empty).Trim().Replace("\r", string.Empty).Replace("\n", string.Empty);
        }
        catch
        {
            _username = string.Empty;
        }
        // create a logger instance for this component
        try
        {
            _logger = LoggerFactory?.CreateLogger("Checkout");
        }
        catch { }
    }

    public void Dispose()
    {
        CartState.OnChange -= HandleCartChanged;
    }

    private async void HandleCartChanged()
    {
        try { await CheckServersAsync(); } catch { }
        try { await InvokeAsync(StateHasChanged); } catch { }
    }

    private void SelectPayment(string method)
    {
        _selectedPayment = method;
    }

    private void SelectStripe()
    {
        _selectedPayment = "stripe";
    }

    private void SelectPaypal()
    {
        _selectedPayment = "paypal";
    }

    private void BackToCart()
    {
        NavigationManager.NavigateTo("/cart");
    }
    private void ContinueShopping()
    {
        NavigationManager.NavigateTo("/");
    }

    private async Task ProceedToPayment()
    {
        _paymentSucceeded = false;

        // If Stripe is selected, create a Checkout Session and immediately redirect the user to Stripe (no simulated UI)
        if (_selectedPayment == "stripe")
        {
            try
            {
                double parsedStripe = 0;
                var formattedStripe = _amount;
                if (!double.TryParse(_amount, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out parsedStripe) || parsedStripe <= 0)
                {
                    parsedStripe = CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
                    formattedStripe = parsedStripe.ToString("F2");
                }

                var stripeResp = await CheckoutApi.CreateStripeSessionAsync(new CreateStripeSessionRequest { Amount = formattedStripe, Description = "SentrySMP purchase" });
                if (stripeResp == null || string.IsNullOrWhiteSpace(stripeResp.Url))
                {
                    _payPalErrorMessage = "Server did not return Stripe checkout URL.";
                    _failureMessage = "Payment failed — server did not return Stripe checkout URL.";
                    _showPaymentCard = true; // show error area
                }
                else
                {
                    NavigationManager.NavigateTo(stripeResp.Url, true);
                    return;
                }
            }
            catch (Exception ex)
            {
                _payPalErrorMessage = ex.Message;
                _failureMessage = "Payment failed — " + ex.Message;
                _showPaymentCard = true;
            }
        }

        // For PayPal and simulated flows show the payment card
        _showPaymentCard = true;

        if (_selectedPayment == "paypal")
        {
            // Server-side create-order + redirect flow (no frontend JS)
            try
            {
                // Use the manually entered amount (fallback to cart total if parsing fails)
                double parsed = 0;
                var formatted = _amount;
                if (!double.TryParse(_amount, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out parsed) || parsed <= 0)
                {
                    // try fallback to cart total
                    parsed = CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
                    formatted = parsed.ToString("F2");
                }

                try
                {
                    var resp = await CheckoutApi.CreateOrderAsync(new CreateOrderRequest { Amount = formatted });
                    if (resp == null || string.IsNullOrWhiteSpace(resp.ApproveUrl))
                    {
                        _payPalErrorMessage = "Server did not return approval URL.";
                        _failureMessage = "Payment failed — server did not return PayPal approval URL.";
                    }
                    else
                    {
                        // Redirect browser to PayPal approval URL (full page load)
                        NavigationManager.NavigateTo(resp.ApproveUrl, true);
                        return;
                    }
                }
                catch (Exception ex)
                {
                    _payPalErrorMessage = $"PayPal error: {ex.Message}";
                    _failureMessage = $"Payment failed — {ex.Message}";
                }
            }
            catch (Exception ex)
            {
                _payPalErrorMessage = ex.Message;
                _failureMessage = "Payment failed — " + ex.Message;
            }
        }
    }

    private async Task CheckServersAsync()
    {
        _serverHealth.Clear();
        try
        {
            var servers = CartState.CartItems
                .Select(ci => ci.Key.Server)
                .Where(s => s != null)
                .GroupBy(s => s!.Id)
                .Select(g => g.First()!)
                .ToList();

            // If the cart contains any rank products, ensure the SMP server is included
            try
            {
                var hasRank = CartState.CartItems.Any(ci => string.Equals(ci.Key.Type ?? string.Empty, "rank", StringComparison.OrdinalIgnoreCase));
                if (hasRank)
                {
                    try
                    {
                        var all = await ServerService.GetAllServersAsync();
                        var smp = all?.FirstOrDefault(s => !string.IsNullOrEmpty(s.Name) && s.Name.IndexOf("smp", StringComparison.OrdinalIgnoreCase) >= 0);
                        if (smp != null && !servers.Any(s => s.Id == smp.Id))
                        {
                            servers.Add(smp);
                        }
                    }
                    catch { }
                }
            }
            catch { }

            foreach (var srv in servers)
            {
                var entry = new ServerHealth { Server = srv };
                try
                {
                    // ICMP ping check to the server IP/host (normalize DB value; ignore port portion if included)
                    var rawHost = srv.RCONIP;
                    var host = NormalizeHost(rawHost);
                    entry.HostUsed = host;
                    entry.PortUsed = srv.RCONPort;
                    if (string.IsNullOrWhiteSpace(host))
                    {
                        entry.Ok = false;
                        entry.Error = "Invalid host";
                        _logger?.LogWarning("Server health: invalid host. Raw='{RawHost}', Normalized='{Host}'", rawHost, host);
                        _serverHealth.Add(entry);
                        continue;
                    }

                    _logger?.LogInformation("Server health: pinging host '{Host}' (raw='{Raw}', port={Port})", host, rawHost, srv.RCONPort);

                    using var ping = new System.Net.NetworkInformation.Ping();
                    System.Net.NetworkInformation.PingReply? reply = null;
                    try
                    {
                        reply = await ping.SendPingAsync(host, 4000);
                    }
                    catch (Exception pex)
                    {
                        entry.Ok = false;
                        entry.Error = pex.Message;
                    }

                    if (reply != null)
                    {
                        if (reply.Status == System.Net.NetworkInformation.IPStatus.Success)
                        {
                            entry.Ok = true;
                        }
                        else
                        {
                            entry.Ok = false;
                            entry.Error = reply.Status == System.Net.NetworkInformation.IPStatus.TimedOut
                                ? "Ping timeout"
                                : $"Ping failed: {reply.Status}";
                        }
                    }
                }
                catch (Exception ex)
                {
                    entry.Ok = false;
                    entry.Error = ex.Message;
                }
                _serverHealth.Add(entry);
            }
        }
        catch (Exception ex)
        {
            try { _logger?.LogWarning(ex, "Server availability check failed"); } catch { }
        }
        _hasUnavailableServers = _serverHealth.Any(h => !h.Ok);
        // Proceed button should be enabled only when there is at least one relevant server
        // and all of them are OK. If there are no servers associated, keep disabled.
        var hasServers = _serverHealth.Count > 0;
        _canProceedToPayment = hasServers && !_hasUnavailableServers;
    }

    // Normalize a DB-provided host value: trim, drop control chars, remove surrounding quotes, and strip optional ":port" suffix (safely for IPv6).
    private string NormalizeHost(string? input)
    {
        var h = input ?? string.Empty;
        try
        {
            // Remove control characters (including zero-width)
            h = System.Text.RegularExpressions.Regex.Replace(h, @"\p{C}", string.Empty);
        }
        catch { }
        h = h.Trim();
        if (h.Length >= 2 && h.StartsWith("\"") && h.EndsWith("\""))
        {
            h = h.Substring(1, h.Length - 2);
        }
        return StripPortIfPresent(h);
    }

    // If host is like "1.2.3.4:25565" or "[2001:db8::1]:25565", strip the port and keep only the address.
    private string StripPortIfPresent(string host)
    {
        if (string.IsNullOrWhiteSpace(host)) return host;
        try
        {
            if (host.StartsWith("["))
            {
                var rb = host.IndexOf(']');
                if (rb > 0)
                {
                    return host.Substring(1, rb - 1);
                }
                return host;
            }
            var idx = host.LastIndexOf(':');
            if (idx > -1)
            {
                var after = host.Substring(idx + 1);
                var allDigits = true;
                for (int i = 0; i < after.Length; i++)
                {
                    if (!char.IsDigit(after[i])) { allDigits = false; break; }
                }
                if (allDigits && after.Length > 0)
                {
                    return host.Substring(0, idx);
                }
            }
        }
        catch { }
        return host;
    }

    private async Task RemoveUnavailableServerItems()
    {
        try
        {
            var unavailableIds = _serverHealth.Where(h => !h.Ok).Select(h => h.Server.Id).ToHashSet();
            var toRemove = CartState.CartItems
                .Where(ci => ci.Key.Server != null && unavailableIds.Contains(ci.Key.Server.Id))
                .Select(ci => ci.Key)
                .ToList();
            foreach (var key in toRemove)
            {
                await CartState.RemoveFromCartAsync(key);
            }
            await CheckServersAsync();
            StateHasChanged();
        }
        catch (Exception ex)
        {
            try { _logger?.LogWarning(ex, "Failed to remove unavailable server items from cart"); } catch { }
        }
    }



    

    // Snapshot of last successfully purchased items (used to show order details after return)
    private List<CartItem>? _lastOrderItems;

    // Last transaction id returned from API when saving a transaction
    private long? _lastTransactionId;

    private string? _payPalErrorMessage;
    private SentrySMP.Shared.DTOs.RconExecutionResult? _rconResult;
    private string? _rconStatusMessage;
    private string? _username;
    private Microsoft.Extensions.Logging.ILogger? _logger;
    // Tracks whether the component has finished its first render on the server
    private bool _hasRendered = false;
    // If a transaction is saved before first render completes, defer RCON execution until after render
    private List<ProductQuantityDto>? _pendingRconExecProducts;
    private string? _pendingRconUsername;
    private bool _clearCartOnRconSuccess = false;
    // Tracks whether the last persisted transaction had amount == 0.00
    private bool _lastTransactionAmountIsZero = false;
    // Set when the page was loaded with ?status=success so we can show a special note
    private bool _wasRedirectStatusSuccess = false;

    private void CancelPayment()
    {
        _showPaymentCard = false;
    }

    // Replace %player% tokens in UI strings with sanitized username
    private string FormatPlayerToken(string? text)
    {
        var user = _username ?? string.Empty;
        if (string.IsNullOrEmpty(text)) return string.Empty;
        try
        {
            return text.Replace("%player%", user, StringComparison.OrdinalIgnoreCase);
        }
        catch
        {
            return text ?? string.Empty;
        }
    }

    // Persist a payment transaction to the API. This is best-effort and does not block the UI on failure.
    private async Task SaveTransactionAsync(string provider, string providerTxId, List<CartItem>? items, string amount, string currency, string status)
    {
        try
        {
            // Snapshot the items immediately to avoid races with clearing the cart later
            var itemsSnapshot = (items ?? CartState.CartItems).Select(ci => new CartItem(ci.Key, ci.Quantity)).ToList();
            try { if (_logger != null) _logger.LogInformation("SaveTransactionAsync START provider={Provider} providerTxId={Tx} amountParam={Amount} itemsSnapshotCount={Count} hasRendered={HasRendered}", provider, providerTxId, amount, itemsSnapshot.Count, _hasRendered); } catch { }
            // Ensure amount is filled from cart if missing
            var computedAmount = amount;
            if (string.IsNullOrWhiteSpace(computedAmount) || computedAmount == "0" || computedAmount == "0.00")
            {
                var total = itemsSnapshot.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
                computedAmount = total.ToString("F2", System.Globalization.CultureInfo.InvariantCulture);
                try { if (_logger != null) _logger.LogInformation("SaveTransactionAsync computedAmount from itemsSnapshot = {ComputedAmount} (itemsCount={Count})", computedAmount, itemsSnapshot.Count); } catch { }
            }
            var itemsForJson = itemsSnapshot.Select(i => new
            {
                id = i.Key.Id,
                name = i.Key.Name,
                type = i.Key.Type,
                server = i.Key.Server?.Name,
                quantity = i.Quantity,
                price = i.Key.Price,
                sale = i.Key.Sale
            }).ToList();

            var username = string.Empty;
            try
            {
                var u = await UserService.GetUsernameAsync();
                username = u ?? string.Empty;
            }
            catch
            {
                username = string.Empty;
            }

            var req = new SentrySMP.Shared.DTOs.CreateTransactionRequest
            {
                Provider = provider,
                ProviderTransactionId = providerTxId,
                Amount = computedAmount,
                Currency = currency ?? "EUR",
                MinecraftUsername = username,
                ItemsJson = JsonSerializer.Serialize(itemsForJson),
                Status = status ?? string.Empty,
                RawResponse = string.Empty
            };

            // Call server-side transactions service directly (runs on server; avoids HTTP roundtrip)
            try
            {
                var tx = await TransactionsService.CreateTransactionAsync(req);
                        if (tx != null)
                    {
                        // Remember whether the amount we saved was zero — used to avoid clearing cart
                        try
                        {
                            if (decimal.TryParse(req.Amount, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out var a))
                            {
                                _lastTransactionAmountIsZero = a == 0m;
                            }
                            else
                            {
                                _lastTransactionAmountIsZero = false;
                            }
                        }
                        catch { _lastTransactionAmountIsZero = false; }
                        _lastTransactionId = tx.Id;
                            _successMessage = $"Payment received — thank you! (ID: {tx.Id})";

                        // After the transaction is saved, attempt to execute RCON commands for the purchased items.
                        try
                        {
                            var user = string.Empty;
                            try
                            {
                                user = await UserService.GetUsernameAsync() ?? string.Empty;
                            }
                            catch { user = string.Empty; }

                            var execProducts = itemsSnapshot.Select(ci => new ProductQuantityDto { Product = ci.Key, Quantity = ci.Quantity }).ToList();
                            if (!_hasRendered)
                            {
                                // Defer RCON execution until after the first render completes to ensure the component
                                // and related services (e.g. UserService, JS interop) are fully ready.
                                _pendingRconExecProducts = execProducts;
                                _pendingRconUsername = user;
                            }
                            else
                            {
                                try
                                {
                                    _logger?.LogInformation("Enqueuing RCON job for tx {TxId} (products={Count})", _lastTransactionId, execProducts?.Count ?? 0);
                                    BackgroundQueue.QueueBackgroundWorkItem(async token =>
                                    {
                                        try
                                        {
                                            _logger?.LogInformation("Background RCON job starting for tx {TxId}", _lastTransactionId);
                                            var rres = await RconService.ExecuteCommandsForProductsAsync(execProducts, user);
                                            await InvokeAsync(async () =>
                                            {
                                                _rconResult = rres;
                                                if (rres != null) ProcessRconResult(rres);
                                                StateHasChanged();
                                                // If we were deferring cart clear until RCON succeeded, clear now on success
                                                try
                                                {
                                                                                if (_clearCartOnRconSuccess && rres != null && rres.AllSucceeded)
                                                                                {
                                                                                    var isZero = await LastTransactionAmountIsZeroAsync();
                                                                                    if (isZero)
                                                                                    {
                                                                                        _logger?.LogWarning("Not clearing cart for tx {TxId} because saved amount was zero; triggering full reload", _lastTransactionId);
                                                                                        try
                                                                                        {
                                                                                            await JS.InvokeVoidAsync("location.reload", true);
                                                                                        }
                                                                                        catch (Exception exReload)
                                                                                        {
                                                                                            _logger?.LogWarning(exReload, "Failed to reload page after zero-amount tx {TxId}", _lastTransactionId);
                                                                                        }
                                                                                        _clearCartOnRconSuccess = false;
                                                                                        StateHasChanged();
                                                                                    }
                                                                                    else
                                                                                    {
                                                                                        _logger?.LogInformation("RCON succeeded for tx {TxId}, clearing cart", _lastTransactionId);
                                                                                        await CartState.ClearCartAsync();
                                                                                        _clearCartOnRconSuccess = false;
                                                                                        StateHasChanged();
                                                                                    }
                                                                                }
                                                }
                                                catch (Exception exClear)
                                                {
                                                    _logger?.LogWarning(exClear, "Failed to clear cart after successful RCON for tx {TxId}", _lastTransactionId);
                                                }
                                            });
                                            _logger?.LogInformation("Background RCON job finished for tx {TxId}", _lastTransactionId);
                                        }
                                        catch (Exception exBackground)
                                        {
                                            _logger?.LogError(exBackground, "Background RCON job failed for tx {TxId}", _lastTransactionId);
                                            try { await InvokeAsync(() => { _failureMessage = _failureMessage ?? $"Warning: failed to execute server commands: {exBackground.Message}"; StateHasChanged(); }); } catch { }
                                        }
                                    });
                                }
                                catch (Exception exQueue)
                                {
                                    _logger?.LogError(exQueue, "Failed to enqueue RCON job for tx {TxId}", _lastTransactionId);
                                    _failureMessage = _failureMessage ?? $"Warning: failed to execute server commands: {exQueue.Message}";
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // Best-effort: log and continue. UI should not fail the payment flow because of RCON problems.
                            _failureMessage = _failureMessage ?? $"Warning: failed to execute server commands: {ex.Message}";
                        }
                }
                else
                {
                    _successMessage = "Payment received — thank you! Your payment has been received.";
                }
            }
            catch (Exception ex)
            {
                _failureMessage = $"Failed to save the payment: {ex.Message}";
            }
        }
        catch (Exception ex)
        {
            _failureMessage = $"Error saving the payment: {ex.Message}";
            Console.WriteLine($"Failed to save transaction: {ex.Message}");
        }
        finally
        {
            StateHasChanged();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Detect redirects from server-side PayPal return (e.g. ?status=success)
            var uri = new Uri(NavigationManager.Uri);
            var qs = QueryHelpers.ParseQuery(uri.Query);
            if (qs.TryGetValue("status", out var status))
            {
                if (status == "success")
                {
                    _wasRedirectStatusSuccess = true;
                    // Capture the items currently in the cart so we can render order details after clearing.
                    _lastOrderItems = CartState.CartItems.Select(ci => new CartItem(ci.Key, ci.Quantity)).ToList();

                    // Infer provider from querystring (Stripe returns session_id, PayPal returns orderId)
                    string providerName = "Manual";
                    string providerTxId = "return";
                    if (qs.TryGetValue("session_id", out var sid) && !string.IsNullOrWhiteSpace(sid))
                    {
                        providerName = "Stripe";
                        providerTxId = sid.ToString();
                    }
                    else if (qs.TryGetValue("orderId", out var oid) && !string.IsNullOrWhiteSpace(oid))
                    {
                        providerName = "PayPal";
                        providerTxId = oid.ToString();
                    }
                    else if (qs.TryGetValue("provider", out var pv) && !string.IsNullOrWhiteSpace(pv))
                    {
                        // honor explicit provider if provided
                        providerName = pv.ToString();
                    }

                    // Persist transaction to API (best-effort)
                    try
                    {
                        await SaveTransactionAsync(providerName, providerTxId, _lastOrderItems, _amount, "EUR", "succeeded");
                    }
                    catch { }

                    try { _logger?.LogInformation("Clearing cart after provider return provider={Provider} tx={TxId} itemsCount={Count}", providerName, _lastTransactionId, CartState.CartItems.Count); } catch { }
                    {
                        var isZero = await LastTransactionAmountIsZeroAsync();
                        if (isZero)
                        {
                            try { _logger?.LogWarning("Not clearing cart after provider return for tx {TxId} because saved amount was zero; triggering full reload", _lastTransactionId); } catch { }
                            try
                            {
                                await JS.InvokeVoidAsync("location.reload", true);
                            }
                            catch (Exception exReload)
                            {
                                try { _logger?.LogWarning(exReload, "Failed to reload page after zero-amount tx {TxId}", _lastTransactionId); } catch { }
                            }
                        }
                        else
                        {
                            await CartState.ClearCartAsync();
                            try { _logger?.LogInformation("Cart cleared after provider return tx={TxId}", _lastTransactionId); } catch { }
                        }
                    }
                    _showPaymentCard = false;
                    _paymentSucceeded = true;
                    _successMessage = "Payment received — thank you! Your payment has been received.";
                    StateHasChanged();

                    // Note: we intentionally do not immediately remove the query string here so the success
                    // message can be shown after redirect. If you prefer the query removed, we can
                    // replace the history entry, but that will also re-initialize component state.
                }
                else if (status == "cancelled")
                {
                    // Show a user-friendly failure message when the payment was cancelled.
                    _failureMessage = "Payment cancelled. You can try the payment again.";
                    StateHasChanged();
                    // Keep the query string for this render so the message is visible; we won't replace the
                    // history entry here to remove it automatically.
                }
            }
            
            // Mark that first render completed and execute any deferred RCON requests.
            _hasRendered = true;
            if (_pendingRconExecProducts != null)
            {
                try
                {
                    var rres = await ExecuteRconWithRetries(_pendingRconExecProducts, _pendingRconUsername ?? string.Empty);
                    _rconResult = rres;
                    if (rres != null)
                    {
                        ProcessRconResult(rres);
                    }
                    // If we were deferring cart clear until RCON succeeded, clear now on success
                    try
                    {
                        if (_clearCartOnRconSuccess && rres != null && rres.AllSucceeded)
                        {
                            if (_lastTransactionAmountIsZero)
                            {
                                _logger?.LogWarning("Not clearing cart for tx {TxId} after deferred RCON because saved amount was zero; triggering full reload", _lastTransactionId);
                                try
                                {
                                    await JS.InvokeVoidAsync("location.reload", true);
                                }
                                catch (Exception exReload)
                                {
                                    _logger?.LogWarning(exReload, "Failed to reload page after zero-amount tx {TxId}", _lastTransactionId);
                                }
                                _clearCartOnRconSuccess = false;
                            }
                            else
                            {
                                _logger?.LogInformation("Deferred RCON succeeded for tx {TxId}, clearing cart", _lastTransactionId);
                                await CartState.ClearCartAsync();
                                _clearCartOnRconSuccess = false;
                            }
                        }
                    }
                    catch (Exception exClear)
                    {
                        _logger?.LogWarning(exClear, "Failed to clear cart after deferred successful RCON for tx {TxId}", _lastTransactionId);
                    }
                }
                catch (Exception ex)
                {
                    _failureMessage = _failureMessage ?? $"Warning: failed to execute server commands after render: {ex.Message}";
                }
                finally
                {
                    _pendingRconExecProducts = null;
                    _pendingRconUsername = null;
                    StateHasChanged();
                }
            }
            }
        }

    // Helper to centralize the RCON result processing so we can reuse it when executing immediately
    // or when executing a deferred request after OnAfterRenderAsync.
    private void ProcessRconResult(SentrySMP.Shared.DTOs.RconExecutionResult rres)
    {
        // More robust evaluation: don't trust AllSucceeded alone.
        var hasNoCommandsMarker = rres.CommandResults != null && rres.CommandResults.Any(cr => cr.CommandText == "<NO_RCON_COMMANDS_FOUND>");
        var anyResults = rres.CommandResults != null && rres.CommandResults.Count > 0;
    var allSucceeded = anyResults && rres.CommandResults != null && rres.CommandResults.All(cr => cr.Succeeded) && !hasNoCommandsMarker;

        if (hasNoCommandsMarker)
        {
            _rconStatusMessage = "No server commands were defined for the purchased products.";
            _failureMessage = _failureMessage ?? "Warning: no server commands were configured for your purchase.";
        }
        else if (allSucceeded)
        {
            _rconStatusMessage = "Server commands were successfully sent.";
        }
        else
        {
            _rconStatusMessage = "Some commands failed to send:";
            // also set a visible failure message area
            _failureMessage = _failureMessage ?? "Warning: some server commands failed. Details below.";
        }

        // Append RCON status to the success message so it remains visible together with the paid message.
        if (!string.IsNullOrWhiteSpace(_rconStatusMessage))
        {
            _successMessage = string.IsNullOrWhiteSpace(_successMessage)
                ? _rconStatusMessage
                : _successMessage + " — " + _rconStatusMessage;
        }
    }

    // Execute RCON commands with a small retry/backoff strategy to tolerate transient network/server issues.
    // Returns the final RconExecutionResult (may contain failed commands) or null if execution could not be attempted.
    private async Task<SentrySMP.Shared.DTOs.RconExecutionResult?> ExecuteRconWithRetries(List<ProductQuantityDto> products, string user)
    {
        if (products == null || products.Count == 0) return null;

        const int maxAttempts = 3;
        var delays = new[] { 500, 1000, 2000 }; // ms

        for (int attempt = 1; attempt <= maxAttempts; attempt++)
        {
            try
            {
                var rres = await RconService.ExecuteCommandsForProductsAsync(products, user);

                // If the service returned null, treat as transient and retry
                if (rres == null)
                {
                    if (attempt < maxAttempts)
                        await Task.Delay(delays[Math.Min(attempt - 1, delays.Length - 1)]);
                    else
                        return null;
                }
                else
                {
                    // If there are failures but also a marker indicating no commands, return immediately.
                    var hasNoCommandsMarker = rres.CommandResults != null && rres.CommandResults.Any(cr => cr.CommandText == "<NO_RCON_COMMANDS_FOUND>");
                    var anyFailed = rres.CommandResults != null && rres.CommandResults.Any(cr => !cr.Succeeded);

                    // If there were transient failures (some commands failed) try again a few times, unless it was "no commands" marker.
                    if (anyFailed && !hasNoCommandsMarker && attempt < maxAttempts)
                    {
                        await Task.Delay(delays[Math.Min(attempt - 1, delays.Length - 1)]);
                        continue;
                    }

                    return rres;
                }
            }
            catch
            {
                // Transient exception – retry a few times
                if (attempt < maxAttempts)
                {
                    await Task.Delay(delays[Math.Min(attempt - 1, delays.Length - 1)]);
                    continue;
                }
                throw;
            }
        }

        return null;
    }

    // Truncate long strings for compact UI rendering (compact version that strips color/control codes)
    private string TruncateCompact(string? s, int maxLen = 60)
    {
        if (string.IsNullOrEmpty(s)) return string.Empty;
        try
        {
            // Remove Minecraft-style formatting codes like '§a' and long sequences like '§x§f§f§e...'
            var withoutCodes = System.Text.RegularExpressions.Regex.Replace(s, "§.", string.Empty);
            // Collapse whitespace/newlines so the text fits in a single table cell
            var singleLine = System.Text.RegularExpressions.Regex.Replace(withoutCodes, "\r\n|\n|\r", " ");
            singleLine = System.Text.RegularExpressions.Regex.Replace(singleLine, "\t| {2,}|\\s+", " ").Trim();
            if (singleLine.Length <= maxLen) return singleLine;
            return singleLine.Substring(0, maxLen) + "...";
        }
        catch
        {
            return s ?? string.Empty;
        }
    }

    // Clean a response into a single-line string without truncation (keeps full length but collapses formatting)
    private string CleanSingleLine(string? s)
    {
        if (string.IsNullOrEmpty(s)) return string.Empty;
        try
        {
            // remove Minecraft-style formatting codes like '§a'
            var withoutCodes = System.Text.RegularExpressions.Regex.Replace(s, "§.", string.Empty);
            // keep only Unicode letters (remove digits, punctuation, whitespace, etc.)
            var lettersOnly = System.Text.RegularExpressions.Regex.Replace(withoutCodes, @"[^\p{L}]", string.Empty);
            const int maxChars = 9; // length before adding ellipsis
            if (lettersOnly.Length <= maxChars) return lettersOnly;
            return lettersOnly.Substring(0, maxChars) + "...";
        }
        catch
        {
            return s ?? string.Empty;
        }
    }

    // Backwards-compatible simple Truncate wrapper (keeps original behavior if used elsewhere)
    private string Truncate(string? s, int maxLen = 120) => TruncateCompact(s, maxLen);

    // Read the persisted transaction to determine whether the saved amount was zero.
    private async Task<bool> LastTransactionAmountIsZeroAsync()
    {
        try
        {
            if (!_lastTransactionId.HasValue) return false;
            var tx = await TransactionsService.GetTransactionAsync(_lastTransactionId.Value);
            if (tx == null) return false;
            return tx.Amount == 0m;
        }
        catch
        {
            return false;
        }
    }
    }
}

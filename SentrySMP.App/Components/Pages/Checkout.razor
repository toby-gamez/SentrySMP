@page "/checkout"
@using SentrySMP.Shared.DTOs
@using Microsoft.AspNetCore.WebUtilities
@using SentrySMP.App.Components.State
@using System.Text.Json
@using System.Net.Http.Json
@inject SentrySMP.App.Components.State.CartState CartState
@inject Microsoft.Extensions.Configuration.IConfiguration Configuration
@inject Microsoft.AspNetCore.Hosting.IWebHostEnvironment Env
@inject NavigationManager NavigationManager
@inject Microsoft.JSInterop.IJSRuntime JS
@inject SentrySMP.Shared.Interfaces.ICheckoutApi CheckoutApi
@inject System.Net.Http.HttpClient Http
@inject SentrySMP.Shared.Interfaces.ITransactionsService TransactionsService
@inject SentrySMP.App.Authentication.UserService UserService
@inject SentrySMP.Shared.Interfaces.IRconService RconService
@rendermode InteractiveServer
<PageTitle>Checkout - SentrySMP</PageTitle>

<div class="main-wrapper">
    <h1 class="main">Checkout</h1>
</div>
    @if (_paymentSucceeded)
    {
        <div style="font-size: 5rem; text-align:center;">
            <i class="bi bi-check-circle"></i> 
        </div>
        <div class="alert alert-success mt-4">
            @(_successMessage ?? "Payment happened successfully. Your cart was cleared.") <a href="/">Continue shopping</a>
        </div>

        @if (_rconResult != null)
        {
            <div class="rcon-result @( _rconResult.AllSucceeded ? "rcon-success" : "rcon-warning")">
                <div class="rcon-header">
                    <i class="bi bi-hdd-network rcon-status-icon"></i>
                    <div>
                        <strong>Server commands</strong>
                        <div class="rcon-summary">@_rconStatusMessage</div>
                    </div>
                </div>
                @if (!_rconResult.AllSucceeded)
                {
                    <ul class="rcon-commands">
                        @foreach (var cr in _rconResult.CommandResults)
                        {
                            <li class="rcon-command @(cr.Succeeded ? "success" : "failed")">
                                <span class="command-text">@cr.CommandText</span>
                                @if (!cr.Succeeded && !string.IsNullOrEmpty(cr.ErrorMessage))
                                {
                                    <span class="command-error">@cr.ErrorMessage</span>
                                }
                                <span class="badge @(cr.Succeeded ? "bg-success" : "bg-danger")">@(cr.Succeeded ? "OK" : "FAILED")</span>
                            </li>
                        }
                    </ul>
                }
            </div>
        }

        @if (_lastOrderItems != null && _lastOrderItems.Count > 0)
        {
            <div class="card mt-3">
                <div class="card-body">
                    <h2>Order details</h2>
                    <table class="table table-sm mt-2">
                        <thead>
                            <tr>
                                <th>Item</th>
                                <th>Server</th>
                                <th class="text-center">Qty</th>
                            </tr>
                        </thead>
                        <tbody>
                            @foreach (var it in _lastOrderItems)
                            {
                                <tr>
                                    <td>@FormatPlayerToken(it.Key.Name)</td>
                                    <td>@(it.Key.Server?.Name ?? "-")</td>
                                    <td class="text-center">@it.Quantity</td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>
            </div>
        }
    }
    else if (CartState.CartItems.Count == 0)
    {
        <div class="alert alert-info mt-4">
            <i class="bi bi-info-circle"></i> Your cart is empty. <a href="/" class="ms-1">Go to store</a>
        </div>
    }
    else
    {
        <div class="cart-total">€@CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity).ToString("F2")</div>
        <div class="card mt-4">
            <div class="card-body">
                <h2 class="card-title">Order summary</h2>
                <table class="table table-sm mt-3">
                    <thead>
                        <tr>
                            <th>Name</th>
                            <th class="text-center">Qty</th>
                            <th class="text-end">Unit</th>
                            <th class="text-end">Line</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var item in CartState.CartItems)
                        {
                            var p = item.Key;
                            var qty = item.Quantity;
                            double unitPrice = p.Sale > 0 ? Convert.ToDouble(p.Price) * (1 - p.Sale / 100.0) : Convert.ToDouble(p.Price);
                            <tr>
                                <td>@FormatPlayerToken(p.Name) <small class="text-muted">@p.Server?.Name</small></td>
                                <td class="text-center">@qty</td>
                                <td class="text-end">€@unitPrice.ToString("F2")</td>
                                <td class="text-end">€@((unitPrice * qty).ToString("F2"))</td>
                            </tr>
                        }
                    </tbody>
                </table>
                <h2 class="mt-3">Choose payment method</h2>
                <div class="mt-2">
                    <div class="payment-options d-flex flex-wrap gap-2">
                        <div class="payment-option @( _selectedPayment=="stripe" ? "selected" : "")" role="button" @onclick="SelectStripe">
                            <div class="d-flex align-items-center gap-2">
                                <i class="bi bi-bank fs-3"></i>
                                <div>
                                    <strong>Stripe</strong>
                                    <div class="small text-muted">You will be redirected to the payment gateway. After successful payment, your items will be delivered to your account automatically. Available payment methods include <b>credit/debit card (Google Pay, Apple Pay, etc.), Bancontact, Multibanco, MobilePay, Klarna, Revolut Pay, and EPS</b>.</div>
                                </div>
                            </div>
                        </div>
                        <div class="payment-option @( _selectedPayment=="paypal" ? "selected" : "")" role="button" @onclick="SelectPaypal">
                            <div class="d-flex align-items-center gap-2">
                                <i class="bi bi-paypal fs-3"></i>
                                <div>
                                    <strong>PayPal</strong>
                                    <div class="small text-muted">You will be redirected to the payment gateway. After successful payment, your items will be delivered to your account automatically. You can choose to pay either with your <b>PayPal account or with a debit card via PayPal</b>.</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="mt-4 d-flex gap-2">
                    <button class="btn btn-primary" @onclick="ProceedToPayment">Proceed to payment</button>
                    @if (Env?.IsDevelopment() == true)
                    {
                        <button class="success" @onclick="DebugSimulatePayment">Debug: Mark as paid</button>
                    }
                    <button class="secondary" @onclick="BackToCart">Back to cart</button>
                </div>

                @if (_showPaymentCard)
                {
                    @if (_selectedPayment == "paypal")
                    {
                        <div class="mt-3">
                            <div id="paypal-button-container"></div>
                            <div class="mt-2">
                                <button class="btn btn-outline-secondary" @onclick="CancelPayment">Cancel</button>
                            </div>
                        </div>
                        @if (!string.IsNullOrWhiteSpace(_payPalErrorMessage))
                        {
                            <div class="alert alert-danger mt-2">PayPal error: @_payPalErrorMessage</div>
                        }
                    }
                    else
                    {
                        <div class="alert alert-warning mt-3">
                            <h6>Payment flow placeholder</h6>
                            <p>You selected <strong>@_selectedPayment</strong>. This is a simulated confirmation screen.</p>
                            <div class="d-flex gap-2">
                                <button class="btn btn-success" @onclick="ConfirmPayment">Mark as paid (simulate)</button>
                                <button class="btn btn-outline-secondary" @onclick="CancelPayment">Cancel</button>
                            </div>
                        </div>
                    }
                }

                @if (_paymentSucceeded)
                {
                    <div class="alert alert-success mt-3">
                        <i class="bi bi-check-circle"></i> @(_successMessage ?? "Payment simulated successfully. Your cart was cleared.") <a href="/">Continue shopping</a>
                    </div>

                    @if (_rconResult != null)
                    {
                        <div class="rcon-result @( _rconResult.AllSucceeded ? "rcon-success" : "rcon-warning")">
                            <div class="rcon-header">
                                <i class="bi bi-hdd-network rcon-status-icon"></i>
                                <div>
                                    <strong>Server commands</strong>
                                    <div class="rcon-summary">@_rconStatusMessage</div>
                                </div>
                            </div>
                            @if (!_rconResult.AllSucceeded)
                            {
                                <ul class="rcon-commands">
                                    @foreach (var cr in _rconResult.CommandResults)
                                    {
                                        <li class="rcon-command @(cr.Succeeded ? "success" : "failed")">
                                            <span class="command-text">@cr.CommandText</span>
                                            @if (!cr.Succeeded && !string.IsNullOrEmpty(cr.ErrorMessage))
                                            {
                                                <span class="command-error">@cr.ErrorMessage</span>
                                            }
                                            <span class="badge @(cr.Succeeded ? "bg-success" : "bg-danger")">@(cr.Succeeded ? "OK" : "FAILED")</span>
                                        </li>
                                    }
                                </ul>
                            }
                        </div>
                    }

                    @if (_lastOrderItems != null && _lastOrderItems.Count > 0)
                    {
                        <div class="card mt-3">
                            <div class="card-body">
                                <h6>Order details</h6>
                                <table class="table table-sm mt-2">
                                    <thead>
                                        <tr>
                                            <th>Item</th>
                                            <th>Server</th>
                                            <th class="text-center">Qty</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        @foreach (var it in _lastOrderItems)
                                        {
                                            <tr>
                                                <td>@FormatPlayerToken(it.Key.Name)</td>
                                                <td>@(it.Key.Server?.Name ?? "-")</td>
                                                <td class="text-center">@it.Quantity</td>
                                            </tr>
                                        }
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    }
                }

                @if (!string.IsNullOrWhiteSpace(_failureMessage))
                {
                    <div class="alert alert-danger mt-3">
                        <i class="bi bi-x-circle"></i> @_failureMessage
                        <div class="mt-2">
                            <a class="btn btn-sm btn-primary" href="/cart">Try again</a>
                        </div>
                    </div>
                }

            </div>
        </div>
    }

@code {
    private string _selectedPayment = "stripe";
    private bool _showPaymentCard = false;
    private bool _paymentSucceeded = false;
    private string _amount = ""; // default amount (start empty; cart total will prefill if available)
    private string? _successMessage;
    private string? _failureMessage;

    protected override async Task OnInitializedAsync()
    {
        CartState.OnChange += StateHasChanged;
        // Load cart from browser storage (important when arriving via redirect)
        try
        {
            await CartState.LoadFromStorageAsync(JS);
        }
        catch { }

        // Prefill amount from cart total if we have items
        var total = CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
        if (total > 0)
        {
            _amount = total.ToString("F2");
        }

        // Load username for UI token replacement
        try
        {
            var u = await UserService.GetUsernameAsync();
            _username = (u ?? string.Empty).Trim().Replace("\r", string.Empty).Replace("\n", string.Empty);
        }
        catch
        {
            _username = string.Empty;
        }
    }

    public void Dispose()
    {
        CartState.OnChange -= StateHasChanged;
    }

    private void SelectPayment(string method)
    {
        _selectedPayment = method;
    }

    private void SelectStripe()
    {
        _selectedPayment = "stripe";
    }

    private void SelectPaypal()
    {
        _selectedPayment = "paypal";
    }

    private void BackToCart()
    {
        NavigationManager.NavigateTo("/cart");
    }

    private async Task ProceedToPayment()
    {
        _paymentSucceeded = false;

        // If Stripe is selected, create a Checkout Session and immediately redirect the user to Stripe (no simulated UI)
        if (_selectedPayment == "stripe")
        {
            try
            {
                double parsedStripe = 0;
                var formattedStripe = _amount;
                if (!double.TryParse(_amount, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out parsedStripe) || parsedStripe <= 0)
                {
                    parsedStripe = CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
                    formattedStripe = parsedStripe.ToString("F2");
                }

                var stripeResp = await CheckoutApi.CreateStripeSessionAsync(new CreateStripeSessionRequest { Amount = formattedStripe, Description = "SentrySMP purchase" });
                if (stripeResp == null || string.IsNullOrWhiteSpace(stripeResp.Url))
                {
                    _payPalErrorMessage = "Server did not return Stripe checkout URL.";
                    _failureMessage = "Payment failed — server did not return Stripe checkout URL.";
                    _showPaymentCard = true; // show error area
                }
                else
                {
                    NavigationManager.NavigateTo(stripeResp.Url, true);
                    return;
                }
            }
            catch (Exception ex)
            {
                _payPalErrorMessage = ex.Message;
                _failureMessage = "Payment failed — " + ex.Message;
                _showPaymentCard = true;
            }
        }

        // For PayPal and simulated flows show the payment card
        _showPaymentCard = true;

        if (_selectedPayment == "paypal")
        {
            // Server-side create-order + redirect flow (no frontend JS)
            try
            {
                // Use the manually entered amount (fallback to cart total if parsing fails)
                double parsed = 0;
                var formatted = _amount;
                if (!double.TryParse(_amount, System.Globalization.NumberStyles.Any, System.Globalization.CultureInfo.InvariantCulture, out parsed) || parsed <= 0)
                {
                    // try fallback to cart total
                    parsed = CartState.CartItems.Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
                    formatted = parsed.ToString("F2");
                }

                var resp = await CheckoutApi.CreateOrderAsync(new CreateOrderRequest { Amount = formatted });
                if (resp == null || string.IsNullOrWhiteSpace(resp.ApproveUrl))
                {
                    _payPalErrorMessage = "Server did not return approval URL.";
                    _failureMessage = "Payment failed — server did not return PayPal approval URL.";
                }
                else
                {
                    // Redirect browser to PayPal approval URL (full page load)
                    NavigationManager.NavigateTo(resp.ApproveUrl, true);
                }
            }
            catch (Exception ex)
            {
                _payPalErrorMessage = ex.Message;
                _failureMessage = "Payment failed — " + ex.Message;
            }
        }
    }

    private async Task ConfirmPayment()
    {
        // Capture snapshot of cart so we can display what was purchased after clearing it.
        _lastOrderItems = CartState.CartItems.Select(ci => new CartItem(ci.Key, ci.Quantity)).ToList();

        // Persist transaction to API (best-effort; failures are logged silently here)
        try
        {
            await SaveTransactionAsync("Manual", "debug", _lastOrderItems, _amount, "EUR", "succeeded");
        }
        catch { }

        // Simulate successful payment and clear cart.
        await CartState.ClearCartAsync();
        _showPaymentCard = false;
        _paymentSucceeded = true;
        _successMessage = "Payment received — thank you! Your payment has been received.";
        StateHasChanged();
    }

    // Development-only helper: simulate a real provider return by redirecting back to this
    // page with ?status=success so the normal return handling runs (clears cart, shows message).
    private Task DebugSimulatePayment()
    {
        if (Env?.IsDevelopment() != true)
        {
            return Task.CompletedTask;
        }

        // Force a full-page load (like a provider redirect) to trigger OnAfterRenderAsync firstRender
        // and the existing ?status=success handling.
        NavigationManager.NavigateTo("/checkout?status=success", true);
        return Task.CompletedTask;
    }

    

    // Snapshot of last successfully purchased items (used to show order details after return)
    private List<CartItem>? _lastOrderItems;

    // Last transaction id returned from API when saving a transaction
    private long? _lastTransactionId;

    private string? _payPalErrorMessage;
    private SentrySMP.Shared.DTOs.RconExecutionResult? _rconResult;
    private string? _rconStatusMessage;
    private string? _username;

    private void CancelPayment()
    {
        _showPaymentCard = false;
    }

    // Replace %player% tokens in UI strings with sanitized username
    private string FormatPlayerToken(string? text)
    {
        var user = _username ?? string.Empty;
        if (string.IsNullOrEmpty(text)) return string.Empty;
        try
        {
            return text.Replace("%player%", user, StringComparison.OrdinalIgnoreCase);
        }
        catch
        {
            return text ?? string.Empty;
        }
    }

    // Persist a payment transaction to the API. This is best-effort and does not block the UI on failure.
    private async Task SaveTransactionAsync(string provider, string providerTxId, List<CartItem>? items, string amount, string currency, string status)
    {
        try
        {
            // Ensure amount is filled from cart if missing
            var computedAmount = amount;
            if (string.IsNullOrWhiteSpace(computedAmount) || computedAmount == "0" || computedAmount == "0.00")
            {
                var total = (items ?? CartState.CartItems).Sum(i => (i.Key.Sale > 0 ? Convert.ToDouble(i.Key.Price) * (1 - i.Key.Sale / 100.0) : Convert.ToDouble(i.Key.Price)) * i.Quantity);
                computedAmount = total.ToString("F2", System.Globalization.CultureInfo.InvariantCulture);
            }

            var itemsForJson = (items ?? new List<CartItem>()).Select(i => new
            {
                id = i.Key.Id,
                name = i.Key.Name,
                type = i.Key.Type,
                server = i.Key.Server?.Name,
                quantity = i.Quantity,
                price = i.Key.Price,
                sale = i.Key.Sale
            }).ToList();

            var username = string.Empty;
            try
            {
                var u = await UserService.GetUsernameAsync();
                username = u ?? string.Empty;
            }
            catch
            {
                username = string.Empty;
            }

            var req = new SentrySMP.Shared.DTOs.CreateTransactionRequest
            {
                Provider = provider,
                ProviderTransactionId = providerTxId,
                Amount = computedAmount,
                Currency = currency ?? "EUR",
                MinecraftUsername = username,
                ItemsJson = JsonSerializer.Serialize(itemsForJson),
                Status = status ?? string.Empty,
                RawResponse = string.Empty
            };

            // Call server-side transactions service directly (runs on server; avoids HTTP roundtrip)
            try
            {
                var tx = await TransactionsService.CreateTransactionAsync(req);
                        if (tx != null)
                    {
                        _lastTransactionId = tx.Id;
                            _successMessage = $"Payment received — thank you! (ID: {tx.Id})";

                        // After the transaction is saved, attempt to execute RCON commands for the purchased items.
                        try
                        {
                            var user = string.Empty;
                            try
                            {
                                user = await UserService.GetUsernameAsync() ?? string.Empty;
                            }
                            catch { user = string.Empty; }

                            var execProducts = (items ?? CartState.CartItems).Select(ci => new ProductQuantityDto { Product = ci.Key, Quantity = ci.Quantity }).ToList();
                            var rres = await RconService.ExecuteCommandsForProductsAsync(execProducts, user);
                            _rconResult = rres;
                            if (rres != null)
                        {
                                if (rres.AllSucceeded)
                                {
                                    _rconStatusMessage = "Server commands were successfully sent.";
                                }
                                else
                                {
                                    _rconStatusMessage = "Some commands failed to send:";
                                    // also set a visible failure message area
                                    _failureMessage = _failureMessage ?? "Warning: some server commands failed. Details below.";
                                }

                                // Append RCON status to the success message so it remains visible together with the paid message.
                                if (!string.IsNullOrWhiteSpace(_rconStatusMessage))
                                {
                                    _successMessage = string.IsNullOrWhiteSpace(_successMessage)
                                        ? _rconStatusMessage
                                        : _successMessage + " — " + _rconStatusMessage;
                                }
                            }
                        }
                        catch (Exception ex)
                        {
                            // Best-effort: log and continue. UI should not fail the payment flow because of RCON problems.
                            _failureMessage = _failureMessage ?? $"Warning: failed to execute server commands: {ex.Message}";
                        }
                }
                else
                {
                    _successMessage = "Payment received — thank you! Your payment has been received.";
                }
            }
            catch (Exception ex)
            {
                _failureMessage = $"Failed to save the payment: {ex.Message}";
            }
        }
        catch (Exception ex)
        {
            _failureMessage = $"Error saving the payment: {ex.Message}";
            Console.WriteLine($"Failed to save transaction: {ex.Message}");
        }
        finally
        {
            StateHasChanged();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            // Detect redirects from server-side PayPal return (e.g. ?status=success)
            var uri = new Uri(NavigationManager.Uri);
            var qs = QueryHelpers.ParseQuery(uri.Query);
            if (qs.TryGetValue("status", out var status))
            {
                if (status == "success")
                {
                    // Capture the items currently in the cart so we can render order details after clearing.
                    _lastOrderItems = CartState.CartItems.Select(ci => new CartItem(ci.Key, ci.Quantity)).ToList();

                    // Infer provider from querystring (Stripe returns session_id, PayPal returns orderId)
                    string providerName = "Manual";
                    string providerTxId = "return";
                    if (qs.TryGetValue("session_id", out var sid) && !string.IsNullOrWhiteSpace(sid))
                    {
                        providerName = "Stripe";
                        providerTxId = sid.ToString();
                    }
                    else if (qs.TryGetValue("orderId", out var oid) && !string.IsNullOrWhiteSpace(oid))
                    {
                        providerName = "PayPal";
                        providerTxId = oid.ToString();
                    }
                    else if (qs.TryGetValue("provider", out var pv) && !string.IsNullOrWhiteSpace(pv))
                    {
                        // honor explicit provider if provided
                        providerName = pv.ToString();
                    }

                    // Persist transaction to API (best-effort)
                    try
                    {
                        await SaveTransactionAsync(providerName, providerTxId, _lastOrderItems, _amount, "EUR", "succeeded");
                    }
                    catch { }

                    await CartState.ClearCartAsync();
                    _showPaymentCard = false;
                    _paymentSucceeded = true;
                    _successMessage = "Payment received — thank you! Your payment has been received.";
                    StateHasChanged();

                    // Note: we intentionally do not immediately remove the query string here so the success
                    // message can be shown after redirect. If you prefer the query removed, we can
                    // replace the history entry, but that will also re-initialize component state.
                }
                else if (status == "cancelled")
                {
                    // Show a user-friendly failure message when the payment was cancelled.
                    _failureMessage = "Payment cancelled.";
                    StateHasChanged();
                    // Keep the query string for this render so the message is visible; we won't replace the
                    // history entry here to remove it automatically.
                }
            }
        }
    }
}
